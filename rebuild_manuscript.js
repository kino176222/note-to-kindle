const fs = require('fs');
const path = require('path');

// オリジナルのNoteファイル（Webクリップ）
const NOTE_FILE_PATH = '/Users/kino/Library/Mobile Documents/iCloud~md~obsidian/Documents/Mynote/10_Inbox/WebClip/【完全無料】初心者向けVibe Coding入門：AIと対話してアプリを作る→Gitで保存→世界に公開｜Kino.md';
// 出力先
const OUTPUT_PATH = path.join(process.env.HOME, 'Desktop', 'vibe_coding_reborn.md');

// ユーザーの手動修正（Good Parts）を定義
// 単純な置換だけでなく、マークダウン構造を整えたもの
const REPLACEMENTS = [
    {
        // 1. 冒頭の挨拶削除 & イントロ修正
        pattern: /こんにちは、Kinoです。[\s\S]*?## このNoteを読み終えたときの「完成形」/,
        replacement: `
## 本書を読み終えたときの「完成形」`
    },
    {
        // 2. 完成形リストの修正（改行除去版）
        pattern: /このNoteのゴールは、「理解」ではありません。[\s\S]*?「作って終わり」ではなく、「世界に出してドヤれる」状態\*\* です。/,
        replacement: `
本書のゴールは、「理解」ではありません。**実際に、公開されたURLを1つ持つこと** です。
最終的に、あなたは👇この状態になります。

- ✅ AIに日本語で頼みながらアプリを作れる
- ✅ 作ったコードを **GitHubに保存** できる
- ✅ **Vercelで公開し、本物のURLを発行** できる
- ✅ エラーが出ても **「スクショ → AI相談」** で前に進める

つまり──**「作って終わり」ではなく、「世界に出してドヤれる」状態** です。`
    },
    {
        // 3. Vibe Codingとは（改行修正）
        pattern: /Vibe Coding（バイブ・コーディング）\*\* という考え方です。[\s\S]*?実際のコードや調整は、AIが担ってくれます。/,
        replacement: `
**Vibe Coding（バイブ・コーディング）** という考え方です。

Vibe Codingとは、**AIと会話しながら開発を進める、新しい作り方。** 従来のプログラミングは、人間がコンピュータの言葉を正確に書く必要がありました。
でも今は違います。

あなたは**「何を作りたいか」「どうしたいか」を日本語で伝えるだけ。**
実際のコードや調整は、AIが担ってくれます。`
    },
    {
        // 4. アンチグラビティの説明（一歩目の軽さ）
        pattern: /Antigravityは違います。[\s\S]*?これ以上の選択肢はありません。/,
        replacement: `Antigravityは違います。

- 完全無料
- 面倒な環境設定ほぼなし
- インストールして、すぐ始められる

だから、 **考える前に触れる** 。
この「一歩目の軽さ」こそが、Vibe Codingが挫折せずに続く最大の理由です。
**「まずは無料で、一番簡単なやつで始めたい」** そんなあなたにとって、これ以上の選択肢はありません。`
    },
    {
        // 5. AIエディタとは（対話形式）
        pattern: /いきなり「Antigravity」と言われても、[\s\S]*?Vibe Codingの正体です。/,
        replacement: `いきなり「Antigravity」と言われても、正直よく分かりませんよね。

まずは結論から。
**AIエディタとは、文章やコードを“自分で全部書かなくても”、AIと一緒に編集できるエディタ** です。

**【普通のエディタとの違い】**
Windowsの「メモ帳」や、Macの「テキストエディット」を想像してください。

あれは、あなたがキーボードを叩かないと一文字も進みません。

でも、AIエディタは違います。
画面の横に、常に **AIが待機** しています。
あなたがやるのは、これだけ。

- 「ここ、もっと分かりやすくして」
- 「この機能、追加したい」
- 「エラー出た。どうすればいい？」

するとAIが、
「かしこまりました」
と言って、**文字やコードを勝手に書き換えてくれる** 。

この **「命令して、作ってもらう」** というスタイルこそが、Vibe Codingの正体です。`
    },
    {
        // 6. Gemini執事
        pattern: /私たちは、\s*無料のAntigravityを使うだけで、[\s\S]*?本当に成立させている理由です。/,
        replacement: `私たちは、無料のAntigravityを使うだけで、**Google製の超優秀な執事（Gemini）** を雇えます。

しかも、難しい設定は不要。
あなたが意識するのは、**「日本語で話しかける」** ことだけです。
つまりAntigravityのすごさは、

- 黒い画面をほぼ触らなくていい
- エラーを調べなくていい
- 「直して」「追加して」と言うだけで進む
こと。

これが、**「考える前に触れる」Vibe Coding** を本当に成立させている理由です。`
    },
    {
        // 7. Node.jsの説明
        pattern: /つまり以前は、[\s\S]*?手に入れる\*\* という意味なんです。/,
        replacement: `つまり以前は、

- Chrome や Safari の中では動く
- でも PCそのものを動かすことはできない
──そんな制限があったんです。

そこで登場したのが **Node.js（ノード・ジェイエス）** です。
これを入れることで JavaScript は、

- Webサイトの見た目を動かすだけでなく
- ファイル操作やサーバー処理など
- PCや裏側の処理も担当できる

ようになります。
つまり Node.js は、**JavaScript の「活動範囲」を一気に広げる仕組み** です。
そして、Node.js を入れる最大のメリットが **npm（エヌピーエム）** という仕組みを使えるようになること。

npm とは、
- 世界中の開発者が作った便利なプログラム部品を
- コマンド一発で追加できる**JavaScript専用の部品倉庫** です。

ログイン機能、デザイン、アニメーション、開発ツール……
多くのものを **ゼロから作る必要はありません** 。

Node.js を入れるということは、 **JavaScriptで「アプリ開発ができる環境」を手に入れる** という意味なんです。`
    }
];

function rebuildDraft() {
    try {
        let content = fs.readFileSync(NOTE_FILE_PATH, 'utf8');

        // ---------------------------------------------------------
        // 1. 基本的なクリーニング
        // ---------------------------------------------------------
        // メタデータ削除
        content = content.replace(/^---[\s\S]*?---\n/, '');
        // 見出し画像削除
        content = content.replace(/!\[見出し画像\].*?\n/, '');
        // 元のタイトル削除
        content = content.replace(/## 【完全無料】.*?\n/, '');
        // リンク [Kino](...) 削除
        content = content.replace(/\[Kino\]\(https:\/\/note\.com\/kino_11\)\n/, '');
        // 区切り線除去
        content = content.replace(/^---+\s*$/gm, '');

        // ---------------------------------------------------------
        // 2. ユーザー修正（Good Parts）の適用
        // ---------------------------------------------------------
        for (const r of REPLACEMENTS) {
            // 正規表現でマッチするか確認
            if (r.pattern.test(content)) {
                content = content.replace(r.pattern, r.replacement);
            } else {
                console.warn(`[WARN] Pattern not found: ${r.pattern}`);
            }
        }

        // ---------------------------------------------------------
        // 2.5 章番号の自動削除（システム側連番と重複しないように）
        // ---------------------------------------------------------
        // ## 1章：タイトル -> ## タイトル
        content = content.replace(/^##\s+(\d+章[：:\s]*|\d+[\.:\s]+)/gm, '## ');
        // ### 1.1 タイトル -> ### タイトル
        content = content.replace(/^###\s+(\d+(\.\d+)+[：:\s]*)/gm, '### ');

        // ---------------------------------------------------------
        // 3. 全体的なフォーマット修正 (Lint & Repair)
        // ---------------------------------------------------------

        // 1. プロンプト（コードブロック）内のMarkdownヘッダー(#)を無効化
        content = content.replace(/```([\s\S]*?)```/g, (match, inner) => {
            if (/[ぁ-んァ-ン]/.test(inner)) {
                let fixed = inner.replace(/(^|\n)\s*#+\s+(.*)/g, '$1■ $2');
                return '```' + fixed + '```';
            }
            return match;
        });
        content = content.replace(/^>\s*#+\s+(.*)/gm, '> ■ $1');

        // 2. 太字ブロックの正規化と改行対応 (Bold Repair)
        // "** ... **" を検出し、その中での改行処理を行う
        content = content.replace(/\*\*([^\*]+?)\*\*/g, (match, inner) => {
            // まず内側の改行と余計なスペースを削除して1行にする
            let cleanInner = inner.replace(/\n/g, '').trim();

            // 句点で改行を入れるが、太字を維持するために "。**\n\n**" に変換
            // 例: "**文A。文B**" -> "**文A。**\n\n**文B**"
            // 文末の句点も対象にする (後ろが閉じ括弧でない限り)
            let linked = cleanInner.replace(/([。])(?![」）])/g, '$1**\n\n**');

            return '**' + linked + '**';
        });

        // 3. 一般箇所の句点改行
        // すでに太字処理で "**\n\n**" になっている箇所（。**）は除外する
        content = content.replace(/([。])(?!\*\*)([^\n」）])/g, '$1\n\n$2');

        // ---------------------------------------------------------
        // 4. 残存ゴミ（スペース付き太字記号）の強制掃除
        // ---------------------------------------------------------

        // 1. 孤立した "**" (スペースに挟まれたもの) を削除
        // 例: "文字 ** 文字" -> "文字  文字"
        content = content.replace(/(^|\s)\*\*(\s|$)/g, '$1$2');

        // 2. 太字マークの内側のスペースを削除 (Start side)
        // "** 文字" -> "**文字"
        content = content.replace(/\*\*[ \t]+/g, '**');

        // 3. 太字マークの内側のスペースを削除 (End side)
        // "文字 **" -> "文字**"
        // ※「文字 **」が閉じタグの場合のみ有効だが、開きタグの手前にスペースがある場合( " **文字" )は上記2で消える。
        // ここは「文字 **」を「文字**」にするので、"A ** B" (AboldB) になってしまうリスクがあるが、
        // 孤立**は削除済みなので、ここは「太字閉じ」の前のスペース除去として機能するはず。
        content = content.replace(/[ \t]+\*\*/g, '**');

        // 4. 空の太字などを削除
        content = content.replace(/\*\*\*\*/g, '');
        content = content.replace(/\*\*\n\n\*\*/g, '\n\n');

        // 5. リストの改行確保
        content = content.replace(/([^\n])\n(- |・|✅|🔲|⭕️|🌀)/g, '$1\n\n$2');

        // 6. 太字の外側のスペース確保（パース用・標準Markdown対応）
        // markdown-it は文字にくっついていても太字判定するが、念のため
        // ただし、日本語の括弧「」などはスペース不要
        content = content.replace(/([^\s\n「（])\*\*(.+?)\*\*/g, '$1 **$2**');
        content = content.replace(/\*\*(.+?)\*\*([^\s\n」）])/g, '**$1** $2');

        // 余計な空行の削除
        content = content.replace(/\n{3,}/g, '\n\n');

        // コードブロック風になっている Rubyプロンプトを修正
        // ```ruby ... ``` で中身に日本語が含まれる場合、プロンプトボックスにする
        // 画像が含まれている場合も救出する
        content = content.replace(/```ruby\n([\s\S]*?)```/g, (match, inner) => {
            // もし画像タグが含まれていたら、コードブロックを解除して中身だけ返す（あとで画像タグは画像としてレンダリングされる）
            if (inner.includes('![画像]')) {
                return inner; // そのままテキストとして返す（画像は表示される）
            }
            // 日本語が含まれていたら「プロンプト」として扱う
            if (/[ぁ-んァ-ン]/.test(inner)) {
                return `\n> **【コピペ用プロンプト】**\n> \n> ${inner.replace(/\n/g, '\n> ')}\n`;
            }
            return match; // そのまま
        });

        // 念のため、画像タグがインデントされているとコードブロックになるので解除
        content = content.replace(/^\s+!\[画像\]/gm, '![画像]');

        // 文中の不要な改行を削除 (日本語の文末 + 改行 + 日本語文頭)
        // 例: "の\n作成" -> "の作成"
        // ただし、箇条書きや見出しは除く
        // 簡易的なロジック: 「、」「。」「文字」のあとの改行 + 「文字」
        // content = content.replace(/([、。])\n(?=[^-\s\n])/g, '$1'); 
        // -> これは副作用が怖いので、先ほど適用した "Good Parts" 以外の場所は一旦そのままにするか、
        // 最小限の結合のみ行う。

        // NoteのMarkdownは段落内改行が多いので、空行がない改行はスペースに置換（英語的）または削除（日本語的）
        // ここでは「空行で区切られていない連続行」を結合する
        // ただし、リストや引用を除く

        // 今回はリスク回避のため、明示的なReplacement以外は「整形」にとどめる。

        // ---------------------------------------------------------
        // 4. 書き出し
        // ---------------------------------------------------------
        fs.writeFileSync(OUTPUT_PATH, content);
        console.log(`Rebuild Complete: ${OUTPUT_PATH}`);

    } catch (e) {
        console.error('Rebuild Failed:', e);
    }
}

rebuildDraft();
